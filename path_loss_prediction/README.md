## Path Loss Prediction (ML) Example

This example adds a path loss prediction use case intended for Uplink Power Control (ULPC).
It demonstrates both `IPipeline` and `IModule` usage and supports two model types:

- **TensorRT MLP**: uses a TensorRT engine if provided, otherwise falls back to a CUDA MLP.
- **XGBoost**: a lightweight decision-stump ensemble executed on GPU.

### Files
- `path_loss_prediction_module.hpp/.cu` — module implementation (`IModule`)
- `path_loss_prediction_pipeline.hpp/.cpp` — pipeline wrapper
- `path_loss_prediction_example.cpp` — pipeline usage
- `path_loss_prediction_module_example.cpp` — module usage
- `generate_synthetic_data.py` — synthetic dataset generator

### Build
From the repository root:

```
cmake -S . -B build \
  -DAERIAL_FRAMEWORK_ROOT=/path/to/aerial-framework/install
cmake --build build -j
```

### Run
```
./build/path_loss_prediction/path_loss_prediction_example --mlp --model path_loss.engine
./build/path_loss_prediction/path_loss_prediction_example --xgboost --model path_loss_xgb.bin
./build/path_loss_prediction/path_loss_prediction_module_example
```

### Synthetic Data Generator
```
python3 path_loss_prediction/generate_synthetic_data.py \
  --samples 50000 --output synthetic_path_loss.csv --freq 3.5
```

### Training Script
Requires `numpy` and `xgboost` (and `torch` only if you want ONNX export).

```
python3 path_loss_prediction/train_path_loss_models.py \
  --input synthetic_path_loss.csv \
  --mlp-out path_loss_mlp.bin \
  --xgb-out path_loss_xgb.bin \
  --onnx-out path_loss_mlp.onnx \
  --trt-engine-out path_loss_mlp.engine
```

Then run:
```
./build/path_loss_prediction/path_loss_prediction_example --model path_loss_mlp.bin
./build/path_loss_prediction/path_loss_prediction_example --model path_loss_xgb.bin
```

### How to Plug Into ULPC
Use the predicted path loss as an input to your ULPC control law:

1. **Feature collection**: RSRP, SINR, distance estimate, carrier frequency,
   shadow fading, UE speed, cell load, buffer state.
2. **Prediction**: run the model per UE or per group each scheduling interval.
3. **Control update**: convert path loss to power command:
   - `P_ul = P0 + alpha * PL_pred + f(delta_mcs, target_sinr)`
4. **Smoothing**: apply EMA or windowed median to prevent oscillations.
5. **Bounds**: clamp to max UE power and regulatory constraints.

### Model Notes
- **TensorRT MLP**: pass a TensorRT engine via `--model path_loss.engine`. If
  a `.bin` model is provided, the module will use the fallback CUDA MLP weights
  from that file. Use the training script's `--onnx-out` and
  `--trt-engine-out` to export ONNX and build a TensorRT engine with `trtexec`
  (set `TRTEXEC=/path/to/trtexec` if needed).
- **XGBoost**: provide a `.bin` model generated by the training script. The
  module loads `feature_idx`, `thresholds`, `left_values`, and `right_values`.

### Framework Call Flow
This example follows the same module call pattern as `user_scheduling`:

1. `set_inputs()`  
2. `configure_io()`  
3. `execute()`  
4. `get_outputs()`  
